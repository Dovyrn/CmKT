<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Logical Zoom Config</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        :root {
            --primary-color: #a020f0;
            --primary-hover: #8010d0;
            --dark-bg: #0a0a0a;
            --darker-bg: #0f0f0f;
            --module-bg: #1a1a1a;
            --light-bg: #222222;
            --light-text: #f0f0f0;
            --medium-text: #888888;
            --success: #10b981;
            --danger: #ef4444;
            --warning: #f59e0b;
            --border-color: #333333;
            --border-radius: 4px;
            --purple-accent: #9d00ff;
            --purple-light: rgba(157, 0, 255, 0.2);
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: var(--dark-bg);
            color: var(--light-text);
            margin: 0;
            padding: 0;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 20px;
        }
        
        header {
            padding: 10px 0;
            text-align: center;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 20px;
        }
        
        .self-destruct {
            background-color: var(--light-bg);
            border: 1px solid var(--border-color);
            color: var(--light-text);
            padding: 10px;
            text-align: center;
            margin-bottom: 20px;
            border-radius: var(--border-radius);
        }
        
        .client-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 10px;
            margin-bottom: 10px;
        }
        
        .client-title {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .client-title h1 {
            margin: 0;
            font-size: 20px;
        }
        
        .client-options {
            color: var(--medium-text);
            font-size: 12px;
            cursor: pointer;
        }
        
        .tab-navigation {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border-radius: var(--border-radius);
            position: relative;
            color: var(--light-text);
        }
        
        .tab.active {
            border: 1px solid var(--purple-accent);
            background-color: transparent;
        }
        
        .settings-icon {
            width: 32px;
            height: 32px;
            background-color: var(--light-bg);
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: var(--border-radius);
            cursor: pointer;
        }
        
        .settings-icon i {
            color: var(--light-text);
            font-size: 18px;
        }
        
        .modules-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .module {
            background-color: var(--module-bg);
            border-radius: var(--border-radius);
            overflow: hidden;
        }
        
        .module-header {
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
        }
        
        .module-name {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .help-icon {
            opacity: 0.6;
            font-size: 14px;
            cursor: help;
        }
        
        .keybind {
            background-color: rgba(0, 0, 0, 0.3);
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 12px;
            color: var(--purple-accent);
        }
        
        .module-toggle {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 20px;
        }
        
        .module-settings {
            padding: 10px 0;
            border-top: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 15px;
        }
        
        .setting-row:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }
        
        .setting-name {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .setting-control {
            display: flex;
            align-items: center;
            gap: 10px;
            min-width: 120px;
            justify-content: flex-end;
        }
        
        /* Custom checkbox styling */
        .checkbox-container {
            display: inline-block;
            position: relative;
            width: 22px;
            height: 22px;
        }
        
        .custom-checkbox {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 20px;
            background-color: transparent;
            border: 1px solid var(--border-color);
            border-radius: 3px;
            cursor: pointer;
        }
        
        .custom-checkbox.checked {
            background-color: var(--purple-accent);
            border-color: var(--purple-accent);
        }
        
        .custom-checkbox.checked::after {
            content: "âœ“";
            color: white;
            font-size: 14px;
        }
        
        /* Custom slider styling */
        .slider-container {
            width: 100%;
            display: flex;
            align-items: center;
        }
        
        .custom-slider {
            position: relative;
            width: 100%;
            height: 6px;
            background-color: var(--light-bg);
            border-radius: 3px;
            overflow: hidden;
        }
        
        .slider-fill {
            position: absolute;
            height: 100%;
            background-color: var(--purple-accent);
            border-radius: 3px;
        }
        
        /* Custom selector styling */
        .selector-value {
            padding: 5px 10px;
            border-radius: var(--border-radius);
            background-color: transparent;
            white-space: nowrap;
            text-align: right;
        }
        
        /* Status message */
        .status {
            padding: 10px;
            border-radius: var(--border-radius);
            margin: 10px 0;
            text-align: center;
            display: none;
        }
        
        .status.visible {
            display: block;
        }
        
        .status.success {
            background-color: rgba(16, 185, 129, 0.2);
            border: 1px solid var(--success);
        }
        
        .status.error {
            background-color: rgba(239, 68, 68, 0.2);
            border: 1px solid var(--danger);
        }
        
        .status.info {
            background-color: rgba(59, 130, 246, 0.2);
            border: 1px solid #3b82f6;
        }
        
        /* Footer buttons */
        .footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            padding: 20px 0;
            position: sticky;
            bottom: 0;
            background-color: var(--dark-bg);
            z-index: 100;
        }
        
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.2s;
        }
        
        .btn-primary {
            background-color: var(--purple-accent);
            color: white;
        }
        
        .btn-primary:hover {
            background-color: var(--primary-hover);
        }
        
        .btn-danger {
            background-color: var(--danger);
            color: white;
        }
        
        .btn-danger:hover {
            background-color: #b91c1c;
        }
        
        /* Tooltip */
        .tooltip {
            position: relative;
        }
        
        .tooltip .tooltip-text {
            visibility: hidden;
            background-color: #2d2d2d;
            color: var(--light-text);
            text-align: center;
            padding: 5px 10px;
            border-radius: 4px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 12px;
            pointer-events: none;
        }
        
        .tooltip:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }
        
        /* Dark scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
        }
        
        ::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #444;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="client-info">
                <div class="client-title">
                    <h1>Logical Zoom</h1>
                </div>
                <div class="client-options">
                    Click to open client options
                </div>
            </div>
        </header>
        
        <div class="self-destruct">
            SELF DESTRUCT [RSHIFT + DELETE]
        </div>
        
        <div id="status-message" class="status">Loading configuration...</div>
        
        <div class="tab-navigation">
            <div class="tab active" data-tab="combat">Combat</div>
            <div class="tab" data-tab="visual">Visual</div>
            <div class="tab" data-tab="movement">Movement</div>
            <div class="tab" data-tab="utility">Utility</div>
            <div class="settings-icon">
                <i class="fas fa-cog"></i>
            </div>
        </div>
        
        <div id="modules-container" class="modules-container">
            <!-- Modules will be loaded here -->
        </div>
        
        <div class="footer">
            <button id="reset-config" class="btn btn-danger">Reset All</button>
            <button id="save-config" class="btn btn-primary">Save Changes</button>
        </div>
    </div>
    
    <script>
        /**
         * Setting type constants
         * @enum {string}
         */
        const SettingType = {
            /** @type {string} Boolean toggle */
            SWITCH: 'switch',
            /** @type {string} Numeric slider */
            SLIDER: 'slider',
            /** @type {string} Text input field */
            TEXT: 'text',
            /** @type {string} Color picker with alpha */
            COLOR: 'color',
            /** @type {string} Dropdown selector */
            SELECTOR: 'selector'
        };

        /**
         * Module settings definition with type annotations
         * Key = module config key, Value = array of setting objects with {key, type}
         */
        const moduleSettings = {
            // Combat modules
            'aimAssistEnabled': [
                {key: 'aimAssistMode', type: SettingType.SELECTOR, options: ['Both', 'Horizontal', 'Vertical'], displayName: 'Target mode'},
                {key: 'aimAssistHitbox', type: SettingType.SELECTOR, options: ['Eye', 'Center', 'Bottom'], displayName: 'Target type'},
                {key: 'aimAssistWeaponOnly', type: SettingType.SWITCH, displayName: 'Weapons only'},
                {key: 'stopOnEdge', type: SettingType.SWITCH, displayName: 'Check block break'},
                {key: 'aimAssistStickyTarget', type: SettingType.SWITCH, displayName: 'Lock target'},
                {key: 'aimAssistTargetPlayers', type: SettingType.SWITCH, displayName: 'Target players'},
                {key: 'aimAssistTargetCrystals', type: SettingType.SWITCH, displayName: 'Target crystals'},
                {key: 'aimAssistTargetEntities', type: SettingType.SWITCH, displayName: 'Target entities'},
                {key: 'aimAssistVisibleTime', type: SettingType.SWITCH, displayName: 'Visibility check'},
                {key: 'aimAssistFOV', type: SettingType.SLIDER, min: 5, max: 180, displayName: 'FOV'},
                {key: 'aimAssistSmoothing', type: SettingType.SLIDER, min: 0.1, max: 1.0, step: 0.01, displayName: 'Speed'},
                {key: 'aimAssistRange', type: SettingType.SLIDER, min: 1.0, max: 10.0, step: 0.1, displayName: 'Range'},
                {key: 'aimAssistRandom', type: SettingType.SLIDER, min: 0.0, max: 5.0, step: 0.1, displayName: 'Jitter'}
            ],

            'backtrackEnabled': [
                {key: 'backtrackWeaponOnly', type: SettingType.SWITCH, displayName: 'Weapons only'},
                {key: 'backtrackDisableOnHit', type: SettingType.SWITCH, displayName: 'Require click'},
                {key: 'backtrackMaxDelay', type: SettingType.SLIDER, min: 50, max: 500, displayName: 'Delay'},
                {key: 'backtrackMinDistance', type: SettingType.SLIDER, min: 0.0, max: 4.0, step: 0.1, displayName: 'Min range'},
                {key: 'backtrackMaxDistance', type: SettingType.SLIDER, min: 2.0, max: 6.0, step: 0.1, displayName: 'Max range'},
                {key: 'backtrackMaxHurtTime', type: SettingType.SLIDER, min: 0, max: 10, displayName: 'Max hurt time'},
                {key: 'backtrackCooldown', type: SettingType.SLIDER, min: 0.0, max: 3.0, step: 0.1, displayName: 'Cooldown'}
            ],

            'HitboxEnabled': [
                {key: 'hitboxExpand', type: SettingType.SLIDER, min: 0, max: 1, step: 0.1, displayName: 'Expand'},
                {key: 'hitboxTargets', type: SettingType.SELECTOR, options: ['Players', 'All Entities'], displayName: 'Targets'}
            ],

            'weaponSwapper': [
                {key: 'firstWeapon', type: SettingType.SELECTOR, options: ['Sword', 'Axe', 'Mace'], displayName: 'First weapon'},
                {key: 'secondWeapon', type: SettingType.SELECTOR, options: ['Sword', 'Axe', 'Mace'], displayName: 'Second weapon'},
                {key: 'weaponSwapBack', type: SettingType.SWITCH, displayName: 'Swap back'}
            ],

            'maceDiveEnabled': [
                {key: 'maceDiveKey', type: SettingType.TEXT, displayName: 'Keybind'},
                {key: 'SwapPacket', type: SettingType.SWITCH, displayName: 'Swap packet'},
                {key: 'groundDetectionHeight', type: SettingType.SLIDER, min: 1, max: 25, displayName: 'Ground detection'},
                {key: 'attackMode', type: SettingType.SELECTOR, options: ['None', 'TriggerBot', 'Silent'], displayName: 'Attack mode'},
                {key: 'autoEquipElytra', type: SettingType.SWITCH, displayName: 'Auto-equip elytra'},
                {key: 'autoSwapChestplate', type: SettingType.SWITCH, displayName: 'Auto-swap chestplate'},
                {key: 'boostStrength', type: SettingType.SLIDER, min: 1, max: 5, displayName: 'Boost strength'},
                {key: 'maxHeight', type: SettingType.SLIDER, min: 10, max: 100, displayName: 'Max height'}
            ],

            'maceDTap': [
                {key: 'axePriority', type: SettingType.SWITCH, displayName: 'Axe priority'},
                {key: 'maceFirstWeapon', type: SettingType.SELECTOR, options: ['Sword', 'Axe', 'Mace'], displayName: 'First weapon'},
                {key: 'maceSecondWeapon', type: SettingType.SELECTOR, options: ['Sword', 'Axe', 'Mace'], displayName: 'Second weapon'},
                {key: 'switchOnly', type: SettingType.SWITCH, displayName: 'Switch only'}
            ],

            // Render modules
            'targetHudToggled': [
                {key: 'animations', type: SettingType.SWITCH, displayName: 'Animations'},
                {key: 'offsetX', type: SettingType.SLIDER, min: -500, max: 500, displayName: 'X offset'},
                {key: 'offsetY', type: SettingType.SLIDER, min: -500, max: 500, displayName: 'Y offset'},
                {key: 'showHead', type: SettingType.SWITCH, displayName: 'Show player head'},
                {key: 'background', type: SettingType.SLIDER, min: 0, max: 1, step: 0.01, displayName: 'Background opacity'}
            ],

            'espEnabled': [
                {key: 'espRenderPlayers', type: SettingType.SWITCH, displayName: 'Render players'},
                {key: 'espPlayerColor', type: SettingType.COLOR, displayName: 'Player color'}
            ],

            'chamsEnabled': [],

            'storageEspEnabled': [
                {key: 'storageEspOpacity', type: SettingType.SLIDER, min: 0, max: 1, step: 0.01, displayName: 'Opacity'},
                {key: 'storageEspTracers', type: SettingType.SWITCH, displayName: 'Tracers'},
                {key: 'chestEspEnabled', type: SettingType.SWITCH, displayName: 'Chests/Barrels'},
                {key: 'enderChestEspEnabled', type: SettingType.SWITCH, displayName: 'Ender chests'},
                {key: 'trappedChestEspEnabled', type: SettingType.SWITCH, displayName: 'Trapped chests'},
                {key: 'hopperEspEnabled', type: SettingType.SWITCH, displayName: 'Hoppers'},
                {key: 'furnaceEspEnabled', type: SettingType.SWITCH, displayName: 'Furnaces'},
                {key: 'shulkerEspEnabled', type: SettingType.SWITCH, displayName: 'Shulker boxes'},
                {key: 'chestEspColor', type: SettingType.COLOR, displayName: 'Chest color'},
                {key: 'enderChestEspColor', type: SettingType.COLOR, displayName: 'Ender chest color'},
                {key: 'trappedChestEspColor', type: SettingType.COLOR, displayName: 'Trapped chest color'},
                {key: 'hopperEspColor', type: SettingType.COLOR, displayName: 'Hopper color'},
                {key: 'furnaceEspColor', type: SettingType.COLOR, displayName: 'Furnace color'},
                {key: 'shulkerEspColor', type: SettingType.COLOR, displayName: 'Shulker color'}
            ],

            // Utility modules
            'sprint': [],
            'noJumpDelay': [],
            'fullBright': [],

            // Developer settings
            'developerMode': [
                {key: 'debugMessages', type: SettingType.SWITCH, displayName: 'Debug messages'}
            ]
        };

        // Module display names
        const moduleDisplayNames = {
            'aimAssistEnabled': 'Aim Assist',
            'backtrackEnabled': 'Backtrack',
            'HitboxEnabled': 'Hitbox',
            'weaponSwapper': 'Weapon Swapper',
            'maceDiveEnabled': 'Mace Dive',
            'maceDTap': 'Mace D-Tap',
            'targetHudToggled': 'Target HUD',
            'espEnabled': 'ESP',
            'chamsEnabled': 'Chams',
            'storageEspEnabled': 'Storage ESP',
            'sprint': 'Sprint',
            'noJumpDelay': 'No Jump Delay',
            'fullBright': 'Full Bright',
            'developerMode': 'Developer Mode'
        };

        // Module descriptions for tooltips
        const moduleDescriptions = {
            'aimAssistEnabled': 'Helps with aiming at targets',
            'backtrackEnabled': 'Delays player movement packets',
            'HitboxEnabled': 'Expands entity hitboxes',
            'weaponSwapper': 'Automatically swaps weapons for maximum damage',
            'maceDiveEnabled': 'Performs aerial attacks with mace and elytra',
            'maceDTap': 'Hits twice with different weapons',
            'targetHudToggled': 'Displays information about your current target',
            'espEnabled': 'Shows outlines around entities',
            'chamsEnabled': 'See players through walls',
            'storageEspEnabled': 'Highlights storage containers',
            'sprint': 'Automatically sprints when moving forward',
            'noJumpDelay': 'Removes delay between jumps',
            'fullBright': 'Maximizes brightness even in dark areas',
            'developerMode': 'Enables debug features and logging'
        };

        // Setting descriptions for tooltips
        const settingDescriptions = {
            // Aim Assist
            'aimAssistMode': 'Which axes to assist aiming on',
            'aimAssistHitbox': 'Which part of the target to aim at',
            'aimAssistWeaponOnly': 'Only activate when holding a weapon',
            'stopOnEdge': 'Stops rotating when target is behind a block',
            'aimAssistStickyTarget': 'Stay locked on the same target',
            'aimAssistVisibleTime': 'Checks if target is visible before aiming',
            'aimAssistFOV': 'Field of view in which aim assist activates',
            'aimAssistSmoothing': 'How smoothly aim moves (lower = faster)',
            'aimAssistRange': 'Maximum distance to targets',
            'aimAssistRandom': 'Adds randomness to aim movements',
            
            // Backtrack
            'backtrackWeaponOnly': 'Only active when holding a weapon',
            'backtrackDisableOnHit': 'Stop backtracking when taking damage',
            'backtrackMaxDelay': 'Maximum time to delay packets (ms)',
            'backtrackMinDistance': 'Minimum distance to activate',
            'backtrackMaxDistance': 'Maximum distance to activate',
            'backtrackMaxHurtTime': 'Maximum hurt time for backtrack',
            'backtrackCooldown': 'Time between activations'
        };

        // Category mapping for modules
        const moduleCategories = {
            'aimAssistEnabled': 'combat',
            'backtrackEnabled': 'combat',
            'HitboxEnabled': 'combat',
            'weaponSwapper': 'combat',
            'maceDiveEnabled': 'combat',
            'maceDTap': 'combat',
            'targetHudToggled': 'visual',
            'espEnabled': 'visual',
            'chamsEnabled': 'visual',
            'storageEspEnabled': 'visual',
            'sprint': 'utility',
            'noJumpDelay': 'utility',
            'fullBright': 'utility',
            'developerMode': 'utility'
        };

        // Global state
        let configData = {};
        let pendingChanges = {};
        let activeTab = 'combat';
        let useLocalMode = true; // Default to local mode

        // Initialize
        document.addEventListener('DOMContentLoaded', async () => {
            try {
                await loadConfig();
                setupEventListeners();
                switchTab('combat'); // Start with combat tab
                
                showStatus('Configuration loaded', 'success', 2000);
            } catch (error) {
                console.error('Initialization error:', error);
                showStatus('Error loading configuration', 'error');
            }
        });

        /**
         * Load configuration from API or generate default data
         */
        async function loadConfig() {
            if (useLocalMode) {
                // Generate default data for testing
                generateDefaultData();
                return;
            }

            try {
                const response = await fetch('/api/config');
                
                if (!response.ok) {
                    throw new Error(`Server returned ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                configData = data.values || {};
                
                console.log('Config loaded from API:', configData);
            } catch (error) {
                console.error('Error loading from API:', error);
                showStatus('Using local data - API not available', 'info', 3000);
                generateDefaultData();
            }
        }

        /**
         * Generate default configuration data for testing
         */
        function generateDefaultData() {
            // Create config data with defaults based on Config.kt values
            configData = {};
            
            // Default values for modules based on Config.kt
            const defaultModuleValues = {
                'aimAssistEnabled': false,
                'backtrackEnabled': false,
                'HitboxEnabled': false, 
                'weaponSwapper': false,
                'maceDiveEnabled': false,
                'maceDTap': false,
                'targetHudToggled': true, // Default enabled
                'espEnabled': true,       // Default enabled
                'chamsEnabled': false,
                'storageEspEnabled': false,
                'sprint': true,           // Default enabled
                'noJumpDelay': true,      // Default enabled
                'fullBright': true,       // Default enabled
                'developerMode': false
            };
            
            // More realistic default values for settings
            const defaultSettingValues = {
                // AimAssist
                'aimAssistMode': 0,
                'stopOnEdge': false,
                'aimAssistVisibleTime': 100,
                'aimAssistSmoothing': 0.5,
                'aimAssistFOV': 60,
                'aimAssistRange': 5.0,
                'aimAssistRandom': 0.5,
                'aimAssistHitbox': 0,
                'aimAssistWeaponOnly': true,
                'aimAssistStickyTarget': true,
                'aimAssistTargetPlayers': true,
                'aimAssistTargetCrystals': false,
                'aimAssistTargetEntities': false,
                
                // Backtrack
                'backtrackMinDistance': 1.0,
                'backtrackMaxDistance': 4.0,
                'backtrackMaxDelay': 200,
                'backtrackMaxHurtTime': 5,
                'backtrackCooldown': 0.5,
                'backtrackDisableOnHit': true,
                'backtrackWeaponOnly': true,
                
                // Hitbox
                'hitboxExpand': 0.1,
                'hitboxTargets': 1,
                
                // Weapon Swapper
                'firstWeapon': 0,
                'secondWeapon': 0,
                'weaponSwapBack': true,
                
                // Mace Dive
                'maceDiveKey': 'V',
                'groundDetectionHeight': 3,
                'attackMode': 1,
                'autoEquipElytra': true,
                'autoSwapChestplate': true,
                'boostStrength': 3,
                'maxHeight': 50,
                'SwapPacket': false,
                
                // Mace D-Tap
                'axePriority': true,
                'maceFirstWeapon': 2,
                'maceSecondWeapon': 2,
                'switchOnly': false,
                
                // Target HUD
                'animations': true,
                'offsetX': 0,
                'offsetY': 0,
                'showHead': true,
                'background': 0.5,
                
                // ESP
                'espRenderPlayers': true,
                'espPlayerColor': {r: 255, g: 255, b: 255, a: 255},
                
                // Storage ESP
                'storageEspOpacity': 0.4,
                'storageEspTracers': false,
                'chestEspEnabled': true, 
                'enderChestEspEnabled': true,
                'trappedChestEspEnabled': true,
                'hopperEspEnabled': true,
                'furnaceEspEnabled': true,
                'shulkerEspEnabled': true,
                'chestEspColor': {r: 184, g: 134, b: 11, a: 160},
                'enderChestEspColor': {r: 128, g: 0, b: 128, a: 160},
                'trappedChestEspColor': {r: 255, g: 44, b: 44, a: 163},
                'hopperEspColor': {r: 128, g: 128, b: 128, a: 160},
                'furnaceEspColor': {r: 128, g: 128, b: 128, a: 160},
                'shulkerEspColor': {r: 245, g: 13, b: 222, a: 153},
                
                // Developer
                'debugMessages': false
            };
            
            // Initialize all module toggles with default values
            for (const moduleKey in moduleSettings) {
                configData[moduleKey] = defaultModuleValues[moduleKey] !== undefined ? 
                    defaultModuleValues[moduleKey] : false;
                
                // Set default values for settings
                moduleSettings[moduleKey].forEach(setting => {
                    const key = setting.key;
                    if (defaultSettingValues[key] !== undefined) {
                        configData[key] = defaultSettingValues[key];
                    } else if (setting.type === SettingType.SWITCH) {
                        configData[key] = false;
                    } else if (setting.type === SettingType.SLIDER) {
                        configData[key] = setting.min || 0;
                    } else if (setting.type === SettingType.TEXT) {
                        configData[key] = '';
                    } else if (setting.type === SettingType.COLOR) {
                        configData[key] = {r: 255, g: 255, b: 255, a: 255};
                    } else if (setting.type === SettingType.SELECTOR) {
                        configData[key] = 0;
                    }
                });
            }
            
            console.log('Default data generated:', configData);
        }

        /**
         * Switch between tabs
         */
        function switchTab(tabName) {
            // Update active tab
            activeTab = tabName;
            
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(tab => {
                if (tab.dataset.tab === tabName) {
                    tab.classList.add('active');
                } else {
                    tab.classList.remove('active');
                }
            });
            
            // Render modules for this tab
            renderModulesForTab(tabName);
        }

        /**
         * Render modules for the active tab
         */
        function renderModulesForTab(tabName) {
            const container = document.getElementById('modules-container');
            container.innerHTML = '';
            
            let moduleCount = 0;
            
            // Find modules for this category
            for (const moduleKey in moduleSettings) {
                if (moduleCategories[moduleKey] === tabName) {
                    const moduleCard = createModuleCard(moduleKey);
                    container.appendChild(moduleCard);
                    moduleCount++;
                }
            }
            
            // Show message if no modules
            if (moduleCount === 0) {
                container.innerHTML = `<div class="module" style="grid-column: span 2;">No modules available for this tab</div>`;
            }
        }

        /**
         * Create a module card
         */
        function createModuleCard(moduleKey) {
            const moduleValue = configData[moduleKey] || false;
            const moduleName = moduleDisplayNames[moduleKey] || moduleKey;
            const moduleDescription = moduleDescriptions[moduleKey] || '';
            
            // Create module container
            const moduleElement = document.createElement('div');
            moduleElement.className = 'module';
            moduleElement.dataset.moduleKey = moduleKey;
            
            // Create module header
            const headerElement = document.createElement('div');
            headerElement.className = 'module-header';
            
            // Module name with help icon
            const nameElement = document.createElement('div');
            nameElement.className = 'module-name';
            
            const helpIcon = document.createElement('span');
            helpIcon.className = 'help-icon tooltip';
            helpIcon.innerHTML = '?';
            
            const tooltipText = document.createElement('span');
            tooltipText.className = 'tooltip-text';
            tooltipText.textContent = moduleDescription;
            helpIcon.appendChild(tooltipText);
            
            nameElement.appendChild(helpIcon);
            nameElement.appendChild(document.createTextNode(' ' + moduleName));
            
            // Keybind display
            const keybindElement = document.createElement('span');
            keybindElement.className = 'keybind';
            keybindElement.textContent = 'NONE';
            
            // Module toggle
            const toggleElement = document.createElement('div');
            toggleElement.className = 'custom-checkbox' + (moduleValue ? ' checked' : '');
            toggleElement.addEventListener('click', function() {
                this.classList.toggle('checked');
                const isChecked = this.classList.contains('checked');
                pendingChanges[moduleKey] = isChecked;
                updateSaveButtonState();
                
                // Also update settings visibility
                const settingsElement = moduleElement.querySelector('.module-settings');
                if (settingsElement) {
                    settingsElement.style.display = isChecked ? 'block' : 'none';
                }
            });
            
            // Add elements to header
            headerElement.appendChild(nameElement);
            headerElement.appendChild(keybindElement);
            headerElement.appendChild(toggleElement);
            moduleElement.appendChild(headerElement);
            
            // Create settings container if module has settings
            const moduleSettings = getModuleSettings(moduleKey);
            if (moduleSettings && moduleSettings.length > 0) {
                const settingsElement = document.createElement('div');
                settingsElement.className = 'module-settings';
                
                // Only show settings if module is enabled
                if (!moduleValue) {
                    settingsElement.style.display = 'none';
                }
                
                // Create settings rows
                moduleSettings.forEach(setting => {
                    const settingRow = createSettingRow(setting, configData[setting.key]);
                    settingsElement.appendChild(settingRow);
                });
                
                moduleElement.appendChild(settingsElement);
            }
            
            return moduleElement;
        }

        /**
         * Get settings for a module
         */
        function getModuleSettings(moduleKey) {
            return moduleSettings[moduleKey] || [];
        }

        /**
         * Create a setting row
         */
        function createSettingRow(setting, value) {
            const row = document.createElement('div');
            row.className = 'setting-row';
            row.dataset.settingKey = setting.key;
            
            // Setting name with help icon
            const nameElement = document.createElement('div');
            nameElement.className = 'setting-name';
            
            const helpIcon = document.createElement('span');
            helpIcon.className = 'help-icon tooltip';
            helpIcon.innerHTML = '?';
            
            const tooltipText = document.createElement('span');
            tooltipText.className = 'tooltip-text';
            tooltipText.textContent = settingDescriptions[setting.key] || setting.displayName;
            helpIcon.appendChild(tooltipText);
            
            nameElement.appendChild(helpIcon);
            nameElement.appendChild(document.createTextNode(' ' + (setting.displayName || setting.key)));
            
            // Setting control
            const controlElement = document.createElement('div');
            controlElement.className = 'setting-control';
            
            // Create control based on type
            switch (setting.type) {
                case SettingType.SWITCH:
                    createCheckbox(controlElement, setting.key, value);
                    break;
                    
                case SettingType.SLIDER:
                    createSlider(controlElement, setting.key, value, setting);
                    break;
                    
                case SettingType.SELECTOR:
                    createSelector(controlElement, setting.key, value, setting);
                    break;
                    
                case SettingType.TEXT:
                    createTextInput(controlElement, setting.key, value);
                    break;
                    
                case SettingType.COLOR:
                    // Simplified for brevity
                    controlElement.textContent = 'Color';
                    break;
                    
                default:
                    controlElement.textContent = String(value);
            }
            
            row.appendChild(nameElement);
            row.appendChild(controlElement);
            
            return row;
        }

        /**
         * Create a checkbox control
         */
        function createCheckbox(container, key, value) {
            const checkbox = document.createElement('div');
            checkbox.className = 'custom-checkbox' + (value ? ' checked' : '');
            checkbox.addEventListener('click', function() {
                this.classList.toggle('checked');
                const isChecked = this.classList.contains('checked');
                pendingChanges[key] = isChecked;
                updateSaveButtonState();
            });
            
            container.appendChild(checkbox);
        }

        /**
         * Create a slider control
         */
        function createSlider(container, key, value, setting) {
            const sliderContainer = document.createElement('div');
            sliderContainer.className = 'slider-container';
            
            const min = setting.min || 0;
            const max = setting.max || 100;
            const range = max - min;
            
            // Calculate percentage for fill
            const percentage = range > 0 ? ((value - min) / range) * 100 : 0;
            
            // Create slider track and fill
            const slider = document.createElement('div');
            slider.className = 'custom-slider';
            
            const fill = document.createElement('div');
            fill.className = 'slider-fill';
            fill.style.width = `${percentage}%`;
            
            slider.appendChild(fill);
            sliderContainer.appendChild(slider);
            
            // Make slider interactive
            slider.addEventListener('click', function(e) {
                const rect = this.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const percentage = x / rect.width;
                const newValue = min + (percentage * range);
                
                // Limit to min/max and apply step if defined
                let finalValue = Math.max(min, Math.min(max, newValue));
                if (setting.step) {
                    finalValue = Math.round(finalValue / setting.step) * setting.step;
                }
                
                // Update fill width
                fill.style.width = `${(finalValue - min) / range * 100}%`;
                
                // Save change
                pendingChanges[key] = finalValue;
                updateSaveButtonState();
            });
            
            container.appendChild(sliderContainer);
        }

        /**
         * Create a selector control
         */
        function createSelector(container, key, value, setting) {
            const options = setting.options || [];
            const selectedOption = options[value] || 'None';
            
            const selectorElement = document.createElement('div');
            selectorElement.className = 'selector-value';
            selectorElement.textContent = selectedOption;
            
            // We'd normally create a dropdown here, but for simplicity
            // in this example we'll just cycle through options on click
            selectorElement.addEventListener('click', function() {
                const currentIndex = options.indexOf(this.textContent);
                const nextIndex = (currentIndex + 1) % options.length;
                this.textContent = options[nextIndex];
                
                pendingChanges[key] = nextIndex;
                updateSaveButtonState();
            });
            
            container.appendChild(selectorElement);
        }

        /**
         * Create a text input control
         */
        function createTextInput(container, key, value) {
            const textValue = document.createElement('div');
            textValue.className = 'selector-value';
            textValue.textContent = value || 'None';
            
            // For simplicity, we'll make it editable on click
            textValue.addEventListener('click', function() {
                const newValue = prompt('Enter value:', this.textContent);
                if (newValue !== null) {
                    this.textContent = newValue;
                    pendingChanges[key] = newValue;
                    updateSaveButtonState();
                }
            });
            
            container.appendChild(textValue);
        }

        /**
         * Set up event listeners
         */
        function setupEventListeners() {
            // Tab navigation
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', function() {
                    switchTab(this.dataset.tab);
                });
            });
            
            // Save button
            document.getElementById('save-config').addEventListener('click', saveChanges);
            
            // Reset button
            document.getElementById('reset-config').addEventListener('click', resetConfig);
            
            // Settings icon
            document.querySelector('.settings-icon').addEventListener('click', function() {
                // This would normally open settings dialog
                alert('Settings menu not implemented in this example');
            });
        }

        /**
         * Update save button state based on pending changes
         */
        function updateSaveButtonState() {
            const saveButton = document.getElementById('save-config');
            const hasChanges = Object.keys(pendingChanges).length > 0;
            
            saveButton.textContent = hasChanges 
                ? `Save Changes (${Object.keys(pendingChanges).length})` 
                : 'Save Changes';
            
            saveButton.style.opacity = hasChanges ? '1' : '0.7';
        }

        /**
         * Save pending changes
         */
        async function saveChanges() {
            const count = Object.keys(pendingChanges).length;
            
            if (count === 0) {
                showStatus('No changes to save', 'info', 2000);
                return;
            }
            
            showStatus(`Saving ${count} change${count === 1 ? '' : 's'}...`, 'info');
            
            if (useLocalMode) {
                // In local mode, just update our data
                for (const key in pendingChanges) {
                    configData[key] = pendingChanges[key];
                }
                
                pendingChanges = {};
                updateSaveButtonState();
                showStatus(`${count} change${count === 1 ? '' : 's'} saved successfully`, 'success', 2000);
                
                // Refresh current tab
                switchTab(activeTab);
                return;
            }
            
            try {
                const response = await fetch('/api/config', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(pendingChanges)
                });
                
                if (!response.ok) {
                    throw new Error(`Server returned ${response.status}: ${response.statusText}`);
                }
                
                const result = await response.json();
                
                if (result.status === 'success') {
                    // Update local config
                    for (const key in pendingChanges) {
                        configData[key] = pendingChanges[key];
                    }
                    
                    // Clear pending changes
                    pendingChanges = {};
                    updateSaveButtonState();
                    
                    showStatus(`${count} change${count === 1 ? '' : 's'} saved successfully!`, 'success', 2000);
                    
                    // Refresh current tab
                    switchTab(activeTab);
                } else {
                    throw new Error(result.message || 'Unknown error');
                }
            } catch (error) {
                console.error('Error saving:', error);
                showStatus(`Error saving changes: ${error.message}`, 'error');
            }
        }

        /**
         * Reset configuration
         */
        async function resetConfig() {
            if (!confirm('Are you sure you want to reset ALL settings to their default values? This cannot be undone.')) {
                return;
            }
            
            showStatus('Resetting all settings to defaults...', 'info');
            
            if (useLocalMode) {
                // In local mode, just regenerate data
                pendingChanges = {};
                updateSaveButtonState();
                
                generateDefaultData();
                switchTab(activeTab);
                
                showStatus('All settings have been reset to defaults', 'success', 2000);
                return;
            }
            
            try {
                const response = await fetch('/api/config/reset', {
                    method: 'POST'
                });
                
                if (!response.ok) {
                    throw new Error(`Server returned ${response.status}: ${response.statusText}`);
                }
                
                const result = await response.json();
                
                if (result.status === 'success') {
                    showStatus('All settings have been reset to defaults. Reloading...', 'success', 2000);
                    
                    // Clear pending changes
                    pendingChanges = {};
                    updateSaveButtonState();
                    
                    // Reload everything after a brief delay
                    setTimeout(async () => {
                        await loadConfig();
                        switchTab(activeTab);
                    }, 1000);
                } else {
                    throw new Error(result.message || 'Unknown error');
                }
            } catch (error) {
                console.error('Error resetting:', error);
                showStatus(`Error resetting settings: ${error.message}`, 'error');
            }
        }

        /**
         * Show status message
         */
        function showStatus(message, type, duration = 0) {
            const statusElement = document.getElementById('status-message');
            statusElement.textContent = message;
            statusElement.className = `status ${type} visible`;
            
            // Auto-hide if duration is provided
            if (duration > 0) {
                setTimeout(() => {
                    statusElement.classList.remove('visible');
                }, duration);
            }
        }
        
        // Toggle local mode - for debugging
        function toggleLocalMode() {
            useLocalMode = !useLocalMode;
            showStatus(`Local mode ${useLocalMode ? 'enabled' : 'disabled'}`, 'info', 2000);
            loadConfig().then(() => switchTab(activeTab));
        }
        
        // Add local mode toggle to window for console access
        window.toggleLocalMode = toggleLocalMode;
    </script>
</body>
</html>