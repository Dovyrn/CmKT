<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Logical Zoom Config</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        :root {
            --primary-color: #4f46e5;
            --primary-hover: #4338ca;
            --dark-bg: #1f2937;
            --darker-bg: #111827;
            --light-bg: #374151;
            --light-text: #f3f4f6;
            --medium-text: #9ca3af;
            --success: #10b981;
            --danger: #ef4444;
            --warning: #f59e0b;
            --border-radius: 8px;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: var(--dark-bg);
            color: var(--light-text);
            margin: 0;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        h1, h2, h3 {
            color: var(--light-text);
        }
        
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: var(--border-radius);
            padding: 8px 16px;
            cursor: pointer;
            margin-right: 8px;
            transition: background-color 0.2s;
        }
        
        button:hover {
            background-color: var(--primary-hover);
        }
        
        button.danger {
            background-color: var(--danger);
        }
        
        button.danger:hover {
            background-color: #b91c1c;
        }
        
        .status {
            padding: 10px;
            border-radius: var(--border-radius);
            margin: 10px 0;
        }
        
        .success {
            background-color: rgba(16, 185, 129, 0.2);
            border: 1px solid var(--success);
        }
        
        .error {
            background-color: rgba(239, 68, 68, 0.2);
            border: 1px solid var(--danger);
        }
        
        .info {
            background-color: rgba(59, 130, 246, 0.2);
            border: 1px solid #3b82f6;
        }
        
        .category-section {
            margin-bottom: 30px;
        }
        
        .category-header {
            background-color: var(--primary-color);
            color: white;
            padding: 10px 15px;
            border-radius: var(--border-radius) var(--border-radius) 0 0;
            font-weight: bold;
        }
        
        .module-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            padding: 15px;
            background-color: var(--darker-bg);
            border-radius: 0 0 var(--border-radius) var(--border-radius);
        }
        
        .module-card {
            background-color: var(--light-bg);
            border-radius: var(--border-radius);
            overflow: hidden;
            transition: all 0.3s;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .module-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.15);
        }
        
        .module-name {
            font-weight: bold;
        }
        
        .module-controls {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .module-controls.has-settings .settings-toggle {
            display: inline-block !important;
            visibility: visible !important;
            opacity: 1 !important;
        }
        
        .module-controls.no-settings .settings-toggle {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
        }
        
        .settings-toggle {
            background: none;
            border: none;
            color: var(--light-text);
            cursor: pointer;
            font-size: 1.1em;
            padding: 0;
            margin: 0;
            transition: color 0.2s;
        }
        
        .settings-toggle:hover {
            color: var(--primary-color);
        }
        
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }
        
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #374151;
            transition: .4s;
            border-radius: 24px;
        }
        
        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .slider {
            background-color: var(--primary-color);
        }
        
        input:checked + .slider:before {
            transform: translateX(26px);
        }
        
        .module-settings {
            padding: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: none;
        }
        
        .setting-item {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .setting-item:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }
        
        .setting-name {
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .setting-description {
            font-size: 0.9em;
            color: var(--medium-text);
            margin-bottom: 10px;
        }
        
        .setting-control {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        /* Slider styles */
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
            width: 100%;
        }
        
        input[type="range"] {
            flex: 1;
            height: 8px;
            border-radius: 4px;
            background: var(--darker-bg);
            appearance: none;
            outline: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
        }
        
        .value-display {
            min-width: 40px;
            text-align: right;
        }
        
        /* Text input styles */
        input[type="text"] {
            background-color: var(--darker-bg);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--light-text);
            padding: 8px;
            border-radius: var(--border-radius);
            width: 100%;
        }
        
        /* Color picker styles */
        .color-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        input[type="color"] {
            border: none;
            border-radius: 4px;
            width: 40px;
            height: 40px;
            cursor: pointer;
        }
        
        .color-preview {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        /* Selector styles */
        select {
            background-color: var(--darker-bg);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--light-text);
            padding: 8px;
            border-radius: var(--border-radius);
            width: 100%;
        }
        
        /* Expanded state */
        .module-card.expanded {
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        
        .module-card.expanded .module-settings {
            display: block !important;
        }
        
        .action-buttons {
            position: sticky;
            bottom: 20px;
            background-color: var(--darker-bg);
            padding: 15px;
            border-radius: var(--border-radius);
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: space-between;
            z-index: 100;
            margin-top: 20px;
        }
        
        .action-buttons button {
            padding: 10px 20px;
        }
        
        /* Fix for settings button visibility */
        .module-controls.has-settings .settings-toggle {
            display: inline-block !important;
        }
        
        .module-controls.no-settings .settings-toggle {
            display: none !important;
        }
        
        /* Fix for module settings display */
        .module-card .module-settings {
            display: none !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Logical Zoom Configuration</h1>
            <div>
                <button id="save-changes">Save All Changes</button>
                <button id="reset-config" class="danger">Reset to Defaults</button>
            </div>
        </header>
        
        <div id="status-message" class="status info">Loading configuration...</div>
        
        <div id="modules-container">
            <!-- Categories and modules will be loaded here -->
        </div>
        
        <div class="action-buttons">
            <div>
                <span id="changes-count">0 changes</span>
            </div>
            <div>
                <button id="save-changes-bottom">Save All Changes</button>
            </div>
        </div>
    </div>

    <script>
        // Store configuration data
        let configData = null;
        let metadataData = null;
        let modulesData = null;
        let dependencyMap = {};
        let pendingChanges = {};
        
        // Complete module to settings mapping
        const moduleSettings = {
            // Combat modules
            'aimAssistEnabled': [
                'aimAssistMode', 'stopOnEdge', 'aimAssistVisibleTime', 'aimAssistSmoothing',
                'aimAssistFOV', 'aimAssistRange', 'aimAssistRandom', 'aimAssistHitbox',
                'aimAssistWeaponOnly', 'aimAssistStickyTarget', 'aimAssistTargetPlayers',
                'aimAssistTargetCrystals', 'aimAssistTargetEntities'
            ],
            
            'backtrackEnabled': [
                'backtrackMinDistance', 'backtrackMaxDistance', 'backtrackMaxDelay',
                'backtrackMaxHurtTime', 'backtrackCooldown', 'backtrackDisableOnHit',
                'backtrackWeaponOnly'
            ],
            
            'HitboxEnabled': ['hitboxExpand', 'hitboxTargets'],
            
            'weaponSwapper': ['firstWeapon', 'secondWeapon', 'weaponSwapBack'],
            
            'maceDiveEnabled': [
                'maceDiveKey', 'groundDetectionHeight', 'attackMode', 'autoEquipElytra',
                'autoSwapChestplate', 'boostStrength', 'maxHeight', 'SwapPacket'
            ],
            
            'maceDTap': ['axePriority', 'maceFirstWeapon', 'maceSecondWeapon', 'switchOnly'],
            
            // Render modules
            'targetHudToggled': ['animations', 'offsetX', 'offsetY', 'showHead', 'background'],
            
            'espEnabled': ['espRenderPlayers', 'espPlayerColor'],
            
            'chamsEnabled': [], // No additional settings
            
            'storageEspEnabled': [
                'storageEspOpacity', 'storageEspTracers', 
                'chestEspEnabled', 'enderChestEspEnabled', 'trappedChestEspEnabled',
                'hopperEspEnabled', 'furnaceEspEnabled', 'shulkerEspEnabled',
                'chestEspColor', 'enderChestEspColor', 'trappedChestEspColor',
                'hopperEspColor', 'furnaceEspColor', 'shulkerEspColor'
            ],
            
            // Utility modules
            'sprint': [], // No additional settings
            
            'noJumpDelay': [], // No additional settings
            
            'fullBright': [], // No additional settings
            
            // Developer settings
            'developerMode': ['debugMessages']
        };
        
        // Initialize
        document.addEventListener('DOMContentLoaded', initializePage);
        
        // Initialize the page
        function initializePage() {
            try {
                // Load config and modules
                loadConfig().then(() => {
                    return loadModules();
                }).then(() => {
                    buildDependencyMap();
                    setupEventListeners();
                    
                    // Update status message
                    document.getElementById('status-message').textContent = 'Configuration loaded successfully';
                    document.getElementById('status-message').className = 'status success';
                    setTimeout(() => {
                        document.getElementById('status-message').style.display = 'none';
                    }, 3000);
                }).catch(error => {
                    document.getElementById('status-message').textContent = `Error: ${error.message}`;
                    document.getElementById('status-message').className = 'status error';
                });
            } catch (error) {
                document.getElementById('status-message').textContent = `Error: ${error.message}`;
                document.getElementById('status-message').className = 'status error';
            }
        }
        
        // Load configuration
        async function loadConfig() {
            try {
                const response = await fetch('/api/config');
                if (!response.ok) {
                    throw new Error(`Server returned ${response.status} ${response.statusText}`);
                }
                
                const data = await response.json();
                configData = data.values;
                metadataData = data.metadata;
                
                console.log('Config loaded:', configData);
                console.log('Metadata loaded:', metadataData);
                
                return data;
            } catch (error) {
                console.error('Error loading config:', error);
                throw error;
            }
        }
        
        // Load modules
        async function loadModules() {
            try {
                const response = await fetch('/api/modules');
                if (!response.ok) {
                    throw new Error(`Server returned ${response.status} ${response.statusText}`);
                }
                
                modulesData = await response.json();
                renderModules();
                
                return modulesData;
            } catch (error) {
                console.error('Error loading modules:', error);
                throw error;
            }
        }
        
        // Build a map of which settings depend on which modules
        function buildDependencyMap() {
            // Start with an empty map
            dependencyMap = {};
            
            // Add known module settings
            for (const moduleKey in moduleSettings) {
                dependencyMap[moduleKey] = [...moduleSettings[moduleKey]];
            }
            
            // Look at metadata to find common patterns
            for (const key in metadataData) {
                // Skip if no metadata
                if (!metadataData[key]) continue;
                
                // Handle common module patterns
                if (key.endsWith('Enabled') || key.endsWith('Toggled')) {
                    // This is likely a module toggle
                    if (!dependencyMap[key]) {
                        dependencyMap[key] = [];
                    }
                }
            }
            
            // Look for settings that might depend on modules
            for (const key in metadataData) {
                if (!metadataData[key]) continue;
                
                // Try to find a potential parent module
                for (const moduleKey in dependencyMap) {
                    // Skip self-references
                    if (moduleKey === key) continue;
                    
                    // Common patterns for dependencies
                    const baseName = moduleKey.replace(/Enabled$|Toggled$/, '');
                    
                    if (key.startsWith(baseName) && key !== moduleKey && !dependencyMap[moduleKey].includes(key)) {
                        // This setting likely belongs to this module
                        dependencyMap[moduleKey].push(key);
                    }
                }
            }
            
            console.log('Dependency map built:', dependencyMap);
        }
        
        // Render modules overview
        function renderModules() {
            const container = document.getElementById('modules-container');
            container.innerHTML = '';
            
            // Create sections for each category in modulesData
            for (const category in modulesData) {
                const categorySection = document.createElement('div');
                categorySection.className = 'category-section';
                
                const categoryHeader = document.createElement('div');
                categoryHeader.className = 'category-header';
                categoryHeader.textContent = category;
                
                const moduleGrid = document.createElement('div');
                moduleGrid.className = 'module-grid';
                
                // Add module cards for this category
                for (const moduleName in modulesData[category]) {
                    const enabled = modulesData[category][moduleName];
                    const configKey = findConfigKeyForModule(moduleName);
                    
                    if (configKey) {
                        const moduleCard = createModuleCard(moduleName, enabled, configKey);
                        moduleGrid.appendChild(moduleCard);
                    }
                }
                
                categorySection.appendChild(categoryHeader);
                categorySection.appendChild(moduleGrid);
                container.appendChild(categorySection);
            }
        }
        
        // Find config key for a module name
        function findConfigKeyForModule(moduleName) {
            // Common patterns
            const patterns = [
                moduleName.toLowerCase() + 'Enabled',
                moduleName.replace(/\s+/g, '') + 'Enabled',
                moduleName.replace(/\s+/g, '').toLowerCase() + 'Enabled',
                moduleName.replace(/\s+/g, '') + 'Toggled',
                moduleName.toLowerCase().replace(/\s+/g, ''),
            ];
            
            // Check each pattern
            for (const pattern of patterns) {
                if (pattern in configData) {
                    return pattern;
                }
            }
            
            // Special cases
            const specialCases = {
                'Target HUD': 'targetHudToggled',
                'ESP': 'espEnabled',
                'Storage ESP': 'storageEspEnabled',
                'Sprint': 'sprint',
                'No Jump Delay': 'noJumpDelay',
                'Full Bright': 'fullBright',
                'Mace Dive': 'maceDiveEnabled',
                'Mace D-Tap': 'maceDTap',
                'Hitbox': 'HitboxEnabled',
                'Weapon Swapper': 'weaponSwapper',
                'Aim Assist': 'aimAssistEnabled',
                'Chams': 'chamsEnabled'
            };
            
            return specialCases[moduleName] || null;
        }
        
        // Create a module card
        function createModuleCard(name, enabled, configKey) {
            const card = document.createElement('div');
            card.className = 'module-card';
            card.dataset.configKey = configKey;
            
            // Improve detection of module settings
            const hasSettings = dependencyMap[configKey] && 
                dependencyMap[configKey].length > 0;
            
            // Create header with name and toggle
            const header = document.createElement('div');
            header.className = 'module-header';
            
            const nameElement = document.createElement('div');
            nameElement.className = 'module-name';
            nameElement.textContent = name;
            
            const controls = document.createElement('div');
            controls.className = `module-controls ${hasSettings ? 'has-settings' : 'no-settings'}`;
            
            // Add settings button if we have related settings
            if (hasSettings) {
                const settingsButton = document.createElement('button');
                settingsButton.className = 'settings-toggle';
                settingsButton.innerHTML = '<i class="fas fa-cog"></i>';
                settingsButton.title = 'Module Settings';
                settingsButton.dataset.moduleKey = configKey;
                
                controls.appendChild(settingsButton);
                
                console.log(`Module ${name} (${configKey}) has settings:`, dependencyMap[configKey]);
                
                // Additional debugging for settings detection
                if (dependencyMap[configKey]) {
                    dependencyMap[configKey].forEach(setting => {
                        console.log(`- Setting: ${setting}, Metadata:`, metadataData[setting]);
                    });
                }
            }
            
            // Add toggle switch
            const toggle = document.createElement('label');
            toggle.className = 'switch';
            
            const checkboxInput = document.createElement('input');
            checkboxInput.type = 'checkbox';
            checkboxInput.checked = enabled;
            
            // Add change listener
            checkboxInput.addEventListener('change', function() {
                pendingChanges[configKey] = this.checked;
                updateChangesCount();
            });
            
            const slider = document.createElement('span');
            slider.className = 'slider';
            
            toggle.appendChild(checkboxInput);
            toggle.appendChild(slider);
            controls.appendChild(toggle);
            
            header.appendChild(nameElement);
            header.appendChild(controls);
            card.appendChild(header);
            
            // Create settings panel if this module has settings
            if (hasSettings) {
                const settingsPanel = document.createElement('div');
                settingsPanel.className = 'module-settings';
                
                // Add settings for this module
                const relatedSettings = dependencyMap[configKey] || [];
                let hasVisibleSettings = false;
                
                relatedSettings.forEach(settingKey => {
                    if (!settingKey) return;
                    
                    const settingData = metadataData[settingKey];
                    if (settingData) {
                        // Clone the setting data to avoid modifying the original
                        const settingDataCopy = JSON.parse(JSON.stringify(settingData));
                        settingDataCopy.key = settingKey;
                        settingDataCopy.value = configData[settingKey];
                        
                        const settingElement = createSettingElement(settingKey, settingDataCopy);
                        if (settingElement) {
                            settingsPanel.appendChild(settingElement);
                            hasVisibleSettings = true;
                        }
                    }
                });
                
                // Only add the settings panel if there are actual settings to show
                if (hasVisibleSettings) {
                    card.appendChild(settingsPanel);
                } else {
                    // If no settings were found, update controls to hide the settings button
                    controls.classList.remove('has-settings');
                    controls.classList.add('no-settings');
                    const settingsButton = controls.querySelector('.settings-toggle');
                    if (settingsButton) {
                        controls.removeChild(settingsButton);
                    }
                }
            }
            
            return card;
        }
        
        // Create a setting control element
        function createSettingElement(key, settingData) {
            if (!settingData || !settingData.type) return null;
            
            const settingItem = document.createElement('div');
            settingItem.className = 'setting-item';
            settingItem.dataset.key = key;
            
            // Setting name and description
            const nameElement = document.createElement('div');
            nameElement.className = 'setting-name';
            nameElement.textContent = settingData.name || key;
            
            const descElement = document.createElement('div');
            descElement.className = 'setting-description';
            descElement.textContent = settingData.description || '';
            
            // Control element based on type
            const controlElement = document.createElement('div');
            controlElement.className = 'setting-control';
            
            // Choose control type based on metadata
            let controlCreated = true;
            switch (settingData.type) {
                case 'switch':
                    addSwitchControl(controlElement, key, settingData.value);
                    break;
                    
                case 'slider':
                    addSliderControl(controlElement, key, settingData);
                    break;
                    
                case 'text':
                    addTextControl(controlElement, key, settingData);
                    break;
                    
                case 'color':
                    addColorControl(controlElement, key, settingData.value);
                    break;
                    
                case 'selector':
                    addSelectorControl(controlElement, key, settingData);
                    break;
                    
                default:
                    // For unknown types, just show the value as text
                    controlElement.textContent = settingData.value !== undefined ? String(settingData.value) : 'Unknown value';
                    controlCreated = !!settingData.value; // Only consider it created if there's a value
            }
            
            // Only create the setting element if a control was successfully created
            if (controlCreated) {
                // Add elements to the setting item
                settingItem.appendChild(nameElement);
                settingItem.appendChild(descElement);
                settingItem.appendChild(controlElement);
                
                return settingItem;
            }
            
            return null;
        }
        
        // Add a switch control
        function addSwitchControl(container, key, value) {
            const toggle = document.createElement('label');
            toggle.className = 'switch';
            
            const input = document.createElement('input');
            input.type = 'checkbox';
            input.checked = value === true;
            
            // Add change listener
            input.addEventListener('change', function() {
                pendingChanges[key] = this.checked;
                updateChangesCount();
            });
            
            const slider = document.createElement('span');
            slider.className = 'slider';
            
            toggle.appendChild(input);
            toggle.appendChild(slider);
            container.appendChild(toggle);
        }
        
        // Add a slider control
        function addSliderControl(container, key, setting) {
            const sliderContainer = document.createElement('div');
            sliderContainer.className = 'slider-container';
            
            const input = document.createElement('input');
            input.type = 'range';
            input.min = setting.min || 0;
            input.max = setting.max || 100;
            input.step = setting.step || (setting.format === 'percent' ? 0.01 : 1);
            input.value = setting.value;
            
            const display = document.createElement('div');
            display.className = 'value-display';
            
            // Format the display value
            function updateDisplayValue() {
                if (setting.format === 'percent') {
                    display.textContent = `${Math.round(input.value * 100)}%`;
                } else {
                    display.textContent = parseFloat(input.value).toFixed(input.step < 1 ? 2 : 0);
                }
            }
            
            updateDisplayValue();
            
            // Add input event for live updates
            input.addEventListener('input', function() {
                updateDisplayValue();
                const numValue = parseFloat(this.value);
                pendingChanges[key] = numValue;
                updateChangesCount();
            });
            
            sliderContainer.appendChild(input);
            sliderContainer.appendChild(display);
            container.appendChild(sliderContainer);
        }
        
        // Add a text input control
        function addTextControl(container, key, setting) {
            const input = document.createElement('input');
            input.type = 'text';
            input.value = setting.value || '';
            input.placeholder = setting.placeholder || '';
            
            // Add change listener
            input.addEventListener('change', function() {
                pendingChanges[key] = this.value;
                updateChangesCount();
            });
            
            container.appendChild(input);
        }
        
        // Add a color picker control
        function addColorControl(container, key, value) {
            if (!value) {
                value = { r: 255, g: 255, b: 255, a: 255 };
            }
            
            const colorContainer = document.createElement('div');
            colorContainer.className = 'color-container';
            
            // Color input
            const colorInput = document.createElement('input');
            colorInput.type = 'color';
            colorInput.value = rgbToHex(value.r, value.g, value.b);
            
            // Alpha slider
            const alphaSlider = document.createElement('input');
            alphaSlider.type = 'range';
            alphaSlider.min = 0;
            alphaSlider.max = 255;
            alphaSlider.value = value.a;
            
            // Color preview
            const preview = document.createElement('div');
            preview.className = 'color-preview';
            preview.style.backgroundColor = `rgba(${value.r}, ${value.g}, ${value.b}, ${value.a / 255})`;
            
            // Update handler
            function updateColor() {
                const rgb = hexToRgb(colorInput.value);
                const alpha = parseInt(alphaSlider.value);
                
                preview.style.backgroundColor = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha / 255})`;
                
                pendingChanges[key] = {
                    r: rgb.r,
                    g: rgb.g,
                    b: rgb.b,
                    a: alpha
                };
                
                updateChangesCount();
            }
            
            // Add event listeners
            colorInput.addEventListener('input', updateColor);
            alphaSlider.addEventListener('input', updateColor);
            
            colorContainer.appendChild(colorInput);
            colorContainer.appendChild(alphaSlider);
            colorContainer.appendChild(preview);
            container.appendChild(colorContainer);
        }
        
        // Add a selector control
        function addSelectorControl(container, key, setting) {
            const select = document.createElement('select');
            
            // Add options
            const options = setting.options || [];
            options.forEach((option, index) => {
                const optionElement = document.createElement('option');
                optionElement.value = index;
                optionElement.textContent = option;
                optionElement.selected = index === setting.value;
                select.appendChild(optionElement);
            });
            
            // Add change listener
            select.addEventListener('change', function() {
                pendingChanges[key] = parseInt(this.value);
                updateChangesCount();
            });
            
            container.appendChild(select);
        }
        
        // Set up event listeners
        function setupEventListeners() {
            // Save changes buttons (both top and bottom)
            document.getElementById('save-changes').addEventListener('click', saveChanges);
            document.getElementById('save-changes-bottom').addEventListener('click', saveChanges);
            
            // Reset config button
            document.getElementById('reset-config').addEventListener('click', resetConfig);
            
            // Add global event listener for settings toggle buttons
            document.addEventListener('click', function(e) {
                // Check if the clicked element is a settings toggle button or its child
                if (e.target.matches('.settings-toggle') || e.target.matches('.settings-toggle *')) {
                    // Find the closest module card
                    const card = e.target.closest('.module-card');
                    if (card) {
                        // Close all other expanded cards
                        document.querySelectorAll('.module-card.expanded').forEach(expandedCard => {
                            if (expandedCard !== card) {
                                expandedCard.classList.remove('expanded');
                            }
                        });
                        
                        // Toggle this card
                        card.classList.toggle('expanded');
                        
                        // Log for debugging
                        console.log('Toggled settings for:', card.dataset.configKey);
                        console.log('Is expanded:', card.classList.contains('expanded'));
                        
                        // Prevent default and stop propagation
                        e.preventDefault();
                        e.stopPropagation();
                    }
                }
            }, true); // Use capture phase for better reliability
        }
        
        // Update the changes counter
        function updateChangesCount() {
            const count = Object.keys(pendingChanges).length;
            document.getElementById('changes-count').textContent = 
                count === 1 ? '1 change' : `${count} changes`;
        }
        
        // Save pending changes
        async function saveChanges() {
            const count = Object.keys(pendingChanges).length;
            
            if (count === 0) {
                showStatus('No changes to save', 'info');
                return;
            }
            
            showStatus(`Saving ${count} change${count === 1 ? '' : 's'}...`, 'info');
            
            try {
                const response = await fetch('/api/config', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(pendingChanges)
                });
                
                if (!response.ok) {
                    throw new Error(`Server returned ${response.status} ${response.statusText}`);
                }
                
                const result = await response.json();
                
                if (result.status === 'success') {
                    // Update local config
                    for (const key in pendingChanges) {
                        configData[key] = pendingChanges[key];
                    }
                    
                    // Clear pending changes
                    pendingChanges = {};
                    updateChangesCount();
                    
                    showStatus(`${count} change${count === 1 ? '' : 's'} saved successfully!`, 'success');
                    
                    // Reload modules to refresh the UI
                    await loadModules();
                } else {
                    throw new Error(result.message || 'Unknown error');
                }
            } catch (error) {
                showStatus(`Error saving changes: ${error.message}`, 'error');
            }
        }
        
        // Reset configuration
        async function resetConfig() {
            if (!confirm('Are you sure you want to reset ALL settings to their default values? This cannot be undone.')) {
                return;
            }
            
            showStatus('Resetting all settings to defaults...', 'info');
            
            try {
                const response = await fetch('/api/config/reset', {
                    method: 'POST'
                });
                
                if (!response.ok) {
                    throw new Error(`Server returned ${response.status} ${response.statusText}`);
                }
                
                const result = await response.json();
                
                if (result.status === 'success') {
                    showStatus('All settings have been reset to defaults. Reloading...', 'success');
                    
                    // Clear pending changes
                    pendingChanges = {};
                    updateChangesCount();
                    
                    // Reload everything after a brief delay
                    setTimeout(async () => {
                        await loadConfig();
                        await loadModules();
                    }, 1500);
                } else {
                    throw new Error(result.message || 'Unknown error');
                }
            } catch (error) {
                showStatus(`Error resetting settings: ${error.message}`, 'error');
            }
        }
        
        // Show status message
        function showStatus(message, type) {
            const statusElement = document.getElementById('status-message');
            statusElement.textContent = message;
            statusElement.className = `status ${type}`;
            statusElement.style.display = 'block';
            
            // Auto-hide success messages
            if (type === 'success') {
                setTimeout(() => {
                    if (statusElement.textContent === message) {
                        statusElement.style.display = 'none';
                    }
                }, 3000);
            }
        }
        
        // RGB to HEX conversion
        function rgbToHex(r, g, b) {
            return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }
        
        // HEX to RGB conversion
        function hexToRgb(hex) {
            // Remove # if present
            hex = hex.replace(/^#/, '');
            
            // Parse hex string
            const bigint = parseInt(hex, 16);
            const r = (bigint >> 16) & 255;
            const g = (bigint >> 8) & 255;
            const b = bigint & 255;
            
            return { r, g, b };
        }
    </script>
</body>
</html>